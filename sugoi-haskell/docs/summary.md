# Haskell

## Chap01: はじめの第一歩

- 中置関数（+, -），前置関数
  - 演算子も「関数」と呼ぶんだね
- 前置関数をバッククォートで囲むと命令型っぽく中値として扱える．
  - `div` など
- Haskell の関数呼び出し
  - 関数名 + 空白区切りで引数を渡す
- `if` は文ではなく式であり，`else` が必ず必要（関数として必ず値を返すため）
- リストは要素が全て同じ型でなければならない
- 文字と文字列は区別する
  - 文字：Char 型．シングルクォート `''` で囲む
  - 文字列：Char 型を要素に持つリストとして定義される
- 連結は `++`
- リストへの要素の追加は `:`
- `++`，`:` 演算子の型に注意
  - `++` の場合，両辺（引数）は同じ型
  - `:` の場合，`リストの要素の型:[リスト]` という形で引数を渡さなければならない

次は「リストの比較」から．

- リストの比較は左から 1 要素ずつ比較されていき，異なる要素間の比較結果が出たら Bool が返る
- 空のリストとの比較は必ず空でないリストが大きい
- 遅延評価
  - 値が必要になった段階で初めて値が決定する
  - 演算が行われる時点で初めて必要となる値を得る
- `stack.yaml` にモジュールを認識させるためには，ディレクトリ名を大文字にする必要がある（`Chap01`，not `chap01`）
- リストのための便利関数
  - head
  - tail（使い道ある？）
  - last
  - init（使い道ある？）
  - length
  - null（リストの空判定）
  - reverse
  - take：数とリストを引数に取り，先頭から指定された数の分要素を「取り出した」リストを返す
  - drop：数とリストを引数に取り，先頭から指定された数の分要素を「除去した」リストを返す
  - maximum / minimum
  - sum：和
  - product：要素積
  - elem：要素検索
- レンジ
  - 無限リスト `[1, 2, ..]`
  - 有限リスト
    - `[1 .. 20]`
    - `[a .. z]`
    - `[A .. Z]`
    - ステップ付き
      - 2 の倍数 `[2, 4 .. 20]`
      - 3 の倍数 `[3, 6 .. 20]`
- 無限リストと take
  - Haskell の遅延評価を利用して，無限リストの先頭からの要素を抽出できる
  - `take 10 [1, 2 ..]` の場合，`[1, 2 ..]` は無限リストだが，最初の 10 個しか要求されていないためそれ以降は計算（評価）されない．
  - cycle：リストを受け取り，その要素を無限に繰り返し，無限リストを生成する
  - repeat：1 つの要素（数，文字列，リストなどなんでも良い）を受け取り，その要素のみが無限に繰り返される無限リストを生成する
  - replicate：単一の要素からなるリストを生成する
- 関数が第一級オブジェクト
  - 関数を「引数」にしたり「返り値」にしたりできる
- モジュールの追加について
  - ビルドする時に，stack がモジュールを認識するために相対パスを考慮したモジュール名の明示をファイルの先頭で行う必要がある．また，モジュール名・モジュールの入ったディレクトリ名の 1 文字目は大文字でなくてはならない．
    - Chap01/Double.hs -> `module Chap01.Double where`
    - A/B/C.hs -> `module A.B.C where`

```haskell
-- cycle：リストの要素の繰り返し
take 10 (cycle [3, 5, 3])
-- [3,5,3,3,5,3,3,5,3,3]

-- repeat：1 つの要素の繰り返し
take 10 (repeat [3, 5, 3])
-- [[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3]]

-- replicate
replicate 10 [3, 5, 3]  -- take 10 (repeat [3, 5, 3]) と同義
-- [[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3],[3,5,3]]
```

モジュール追加する時に必要なのは以下 4 つ．

- モジュールを追加する際に必要なこと
  - src 配下に新しくディレクトリを作成して置く
  - ディレクトリ名の 1 文字目を大文字にする（stack が認識できるように）
  - ファイル名の 1 文字目を大文字にする（stack が認識できるように）
  - ファイルの先頭に `module [相対パス].[ファイル名] where` を追加する

タプル p.18 ~ p.22

- Tuple
  - 固定長
  - ヘテロ（複数の違う方の要素が格納できる）
- **タプルはサイズも型の一部**
  - サイズ 2 のタプル（ペア），サイズ 3 のタプル（トリプル）はそれぞれ違う方として扱われる
- **タプルの要素の型もタプルの型の一部**
  - 長さが同じで違う型を含むタプルを区別できる

例えば，座標を実装するときに便利．

```haskell
-- リストを要素に持つリストだと，長さの異なるリストを検出できない
planes = [[1, 2], [6, 8, 11], [5, 4]]

-- タプルだと，長さも型の一部であるためコンパイル時に型エラーを検出できる
planes = [(1, 2), (6, 8, 11), (5, 4)]  -- ERROR
planes = [(1, 2), (6, 8), (5, 4)]  -- OK!
```

内包表記

```haskell
-- p.21: 練習 - 直角三角形を見つける
-- 3 辺の長さは全て整数である
-- 各辺の長さは 10 以下である
-- 周囲の長さは 24 に等しい
triangle =
    [ (a, b, c)
    | c <- [1 .. 10]
    , a <- [1 .. c]  -- a が斜辺 c を超えないようにする
    , b <- [1 .. a]  -- b > a は考えなくて良い (a, b, c) = (6, 8, 10), (8, 6, 10) は同じ
    , let aa = a ^ 2
    , let bb = b ^ 2
    , let cc = c ^ 2
    , aa + bb == cc
    , a + b + c == 24
    ]
```

- 関数型プログラミングの典型例
  - 最初に解の候補となる集合を生成し，それから 1 つ（もしくは複数）の解に辿り着くまで変換とフィルタリングを行うという手法は，関数型プログラミングでよく用いられるパターン

## Chap02: 型を信じろ！

2020/06/14 start

## Haskell の印象

- 2020/06/12
  - 「純粋関数型」ってどういう意味
  - `+` や `-` を演算子ではなく，中置関数と読んでいるのが不思議．
- 2020/06/13
  - まだあまり分かってない
  - 遅延評価により無限リストが扱えるというのは面白いと思った
  - 集合の内包的定義と似た形でリスト内包表記が書けるのわかりやすくて良い
  - 内包表記は Python の内包表記をよく使うのでスッと入ってきた
